name: "TASK-B.01_Start-Task_on-Manual_MAN"

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  start-next-task:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
    
    steps:
      - name: Check if automation is enabled
        id: check_enabled
        run: |
          # Check if AUTOMATION_ENABLED variable exists and is set to true
          if [ "${{ vars.AUTOMATION_ENABLED }}" != "true" ]; then
            echo "Automation is disabled. Set AUTOMATION_ENABLED repository variable to 'true' to enable."
            echo "enabled=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          echo "enabled=true" >> $GITHUB_OUTPUT
      
      - name: Checkout repository
        if: steps.check_enabled.outputs.enabled == 'true'
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Find next uncompleted task
        if: steps.check_enabled.outputs.enabled == 'true'
        id: find_task
        run: |
          # Read the development plan and find the first uncompleted task
          PLAN_FILE="LIGHTJOCKEY_Entwicklungsplan.md"
          
          # Use Python for more reliable parsing
          python3 << 'PYEOF' > task_info.txt
          import re
          import sys
          
          # Read the development plan
          with open('LIGHTJOCKEY_Entwicklungsplan.md', 'r', encoding='utf-8') as f:
              lines = f.readlines()
          
          # Parse the checklist table to find which tasks are completed
          completed_tasks = set()
          in_checklist = False
          
          for line in lines:
              # Detect when we're in the checklist section
              if 'Master Checkliste' in line or 'Execution Checklist' in line:
                  in_checklist = True
                  continue
              
              if in_checklist:
                  # Parse table rows - split by tabs or multiple spaces
                  parts = re.split(r'\t+|\s{2,}', line.strip())
                  if len(parts) >= 3 and parts[0].isdigit():
                      task_num = parts[0]
                      status = parts[2].strip()
                      if status == '✅':
                          completed_tasks.add(int(task_num))
          
          # Find all tasks in the document
          all_tasks = []
          for line in lines:
              match = re.match(r'^Task (\d+) —\s*(.+)', line)
              if match:
                  task_num = int(match.group(1))
                  task_title = match.group(2).strip()
                  all_tasks.append((task_num, task_title))
          
          # Find first uncompleted task
          first_uncompleted = None
          for task_num, task_title in sorted(all_tasks):
              if task_num not in completed_tasks:
                  first_uncompleted = (task_num, task_title)
                  break
          
          if first_uncompleted:
              print(f"{first_uncompleted[0]}")
              print(f"{first_uncompleted[1]}")
          else:
              print("NONE")
              print("")
          PYEOF
          
          # Read the output
          TASK_NUM=$(sed -n '1p' task_info.txt)
          TASK_TITLE=$(sed -n '2p' task_info.txt)
          rm -f task_info.txt
          
          if [ "$TASK_NUM" = "NONE" ]; then
            echo "No uncompleted tasks found. Automation cycle complete!"
            echo "has_task=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "has_task=true" >> $GITHUB_OUTPUT
          echo "Found uncompleted task: Task $TASK_NUM — $TASK_TITLE"
          
          # Create branch name
          BRANCH_NAME="feature/task-${TASK_NUM}-autogenerated"
          
          # Clean task text for title (limit to 80 chars)
          TASK_TITLE_SHORT=$(echo "$TASK_TITLE" | cut -c1-80)
          
          echo "task_num=$TASK_NUM" >> $GITHUB_OUTPUT
          echo "task_title=$TASK_TITLE_SHORT" >> $GITHUB_OUTPUT
          echo "task_text=$TASK_TITLE" >> $GITHUB_OUTPUT
          echo "branch_name=$BRANCH_NAME" >> $GITHUB_OUTPUT
      
      - name: Create feature branch
        if: steps.check_enabled.outputs.enabled == 'true' && steps.find_task.outputs.has_task == 'true'
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          BRANCH_NAME="${{ steps.find_task.outputs.branch_name }}"
          
          # Check if branch already exists
          if git ls-remote --heads origin "$BRANCH_NAME" | grep -q "$BRANCH_NAME"; then
            echo "Branch $BRANCH_NAME already exists. Skipping task creation."
            exit 0
          fi
          
          # Create and push new branch
          git checkout -b "$BRANCH_NAME"
          git push origin "$BRANCH_NAME"
      
      - name: Create GitHub Issue
        if: steps.check_enabled.outputs.enabled == 'true' && steps.find_task.outputs.has_task == 'true'
        id: create_issue
        uses: actions/github-script@v7
        with:
          script: |
            const taskTitle = `${{ steps.find_task.outputs.task_title }}`;
            const taskText = `${{ steps.find_task.outputs.task_text }}`;
            const taskNum = `${{ steps.find_task.outputs.task_num }}`;
            
            // Check if issue already exists
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'autogenerated'
            });
            
            const issueExists = existingIssues.data.some(issue => 
              issue.title.includes(taskTitle)
            );
            
            if (issueExists) {
              console.log('Issue already exists for this task');
              return;
            }
            
            // Create new issue with copilot-task label for agentic workflow
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: taskTitle,
              body: `## Auto-generated Task\n\n${taskText}\n\n---\n\n**Source:** LIGHTJOCKEY_Entwicklungsplan.md\n**Task Number:** ${taskNum}\n**Branch:** \`${{ steps.find_task.outputs.branch_name }}\`\n\nThis issue was automatically created by the automation workflow.\n\n## Implementation Instructions\n\n@copilot Please implement this task according to the development plan in LIGHTJOCKEY_Entwicklungsplan.md.\n\nFollow the existing code patterns and architecture:\n- Use MVVM pattern\n- Add comprehensive unit tests\n- Update documentation\n- Follow C# and WPF best practices\n\nSee the development plan for detailed requirements.`,
              labels: ['autogenerated', 'copilot-task']
            });
            
            console.log(`Created issue #${issue.data.number}`);
            return issue.data.number;
      
      - name: Create Draft Pull Request
        if: steps.check_enabled.outputs.enabled == 'true' && steps.find_task.outputs.has_task == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const taskTitle = `${{ steps.find_task.outputs.task_title }}`;
            const taskNum = `${{ steps.find_task.outputs.task_num }}`;
            const branchName = `${{ steps.find_task.outputs.branch_name }}`;
            const issueNumber = `${{ steps.create_issue.outputs.result }}`;
            
            // Check if PR already exists
            const existingPRs = await github.rest.pulls.list({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              head: `${context.repo.owner}:${branchName}`
            });
            
            if (existingPRs.data.length > 0) {
              console.log('PR already exists for this branch');
              return;
            }
            
            // Create draft PR
            const pr = await github.rest.pulls.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `Task ${taskNum}: ${taskTitle}`,
              head: branchName,
              base: 'main',
              body: `## Auto-generated Pull Request\n\n${taskTitle}\n\n---\n\nCloses #${issueNumber}\n\nThis PR was automatically created by the automation workflow.\n\n**Next Steps:**\n1. AI coding assistant will implement the required changes\n2. CI will build and test automatically\n3. On success, PR will be auto-merged`,
              draft: true
            });
            
            console.log(`Created draft PR #${pr.data.number}`);
